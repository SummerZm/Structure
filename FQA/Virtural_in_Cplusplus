 问题1: 类A继承类B和抽象类C，类C具有和类B同原型的纯虚函数，此时想在类A中调用类B的实现，如何重载?
 类A必须实现类C的纯虚函数, 在新的实现里调用类B同名函数. 

 问题2: this指针什么时候能省略？什么时候不能省略？
 当成员是当前类拥有时可以省略
 当成员是继承来的时候，不能省略。需要通过指针向上转型调用父类的函数或者指定父类函数。

 问题3: 虚函数的能隔代继承吗？
 如果子类实现抽象类的纯虚函数，派生自该子类的新类可以不实现抽象类中的函数。

 问题4: 多态主要是为了解决什么问题?
 缺陷: 将派生类赋给基类的指针或引用，则将会使用派生类的数据和基类的成员函数。
 多态的目的是：即使赋给了基类指针/引用，使用的仍是派生类的数据和成员函数。

 问题5: 派生抽象类时实现纯虚函数，需要在派生类中再一次声明该函数的原型

 问题6:为什么使用友元重载? 友元重载的方法是?
	对+，—， ==， != 使用友元重载可以获得对称自动类型转换的特性
	声明友元模板函数的方法：
	  // 前置声明
	  template<typename T> class xxx;
	  template<typename T> bool operator=={const T&, const T&};

	  template<typename T> 
	  class xxx 
	  {
	  	public:
			friendly bool operator==<>{const T&, const T&};
	  }
	
	模板的目的: 重用算法-建立与类型无关的数据存储结构.
	以全局友元的方式重载模板操作符!=, == 对称的处理数据 -- [这一部分交由容器存储的类型自己去实现，而不是通过友元复杂化了]

 问题7: 泛型的比较应该通过函数指针实现？还是交由对应类的重载成员操作符函数实现？两者都要提供。
 问题8: 虚析构函数的必要性? 如果不使用虚析构，派生类对象赋值给基类指针时，很可能会出现内存泄漏。
 问题9: 为什么const对象无法调用public成员函数？ const对象只能访问类的const public成员。
